\documentclass[a4paper, 12pt]{article}
\usepackage{a4wide}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{color}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{bibliography.bib}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

    \title{A Graphical Programming Language Editor}
    \author{Candidate No. 198719}
    \date{Interim Report}
    \clearpage\maketitle
    \thispagestyle{empty}

    \newpage\clearpage\thispagestyle{empty}
    \tableofcontents
    \newpage
    \setcounter{page}{1}

    \section{Introduction}
    Graphical programming can be a fantastic and intuitive way to introduce new programmers to
    the scene. When programmers ask others for assistance, those helping typically do so in a visual 
    style, using whiteboards, drawing flowcharts, with boxes and arrows indicating the flow 
    of the program. Why can't we make programs in the same style if we find it so helpful to read? 
    The concept behind graphical programming is specifying the elements of the program graphically 
    rather than textually~\cite{dehouck2015maturity}.

    Popular examples of graphical programming include Scratch, as well as a personal favourite that 
    I used during my GCSE Computing education, App Inventor!
    What's clever about Scratch is its simplicity due to the block-based visual programming, aimed 
    towards younger children to help them get into coding!

    \begin{figure}[h]
        \centering
        \includegraphics[width=160mm]{scratch_image}
        \caption{Scratch's visual scripting over a white canvas~\cite{thescratchteam}.}
    \end{figure}

    \clearpage
    MIT App Inventor is one of my personal favourites after experiencing it myself during GCSEs, 
    having to building an on-campus application for a University! It uses a graphical user 
    interface, similar to Scratch, as well as providing the blocks that you can use, visible on 
    the left hand side.

    \begin{figure}[h]
        \centering
        \includegraphics[width=150mm]{app_inventor}
        \caption{MIT App Inventor graphical programming~\cite{adafruit}.}
    \end{figure}

    Both what Scratch and App Inventor do superbly is colour code their blocks to identify 
    exactly what they are representing. There are colour coded blocks for variables, events 
    and controls, and so on! For instance in App Inventor, variables are coloured in Orange 
    blocks, and procedures and show in a big purple block, encapsulating all the blocks like 
    a function.

        \subsection{Aims}
            The aim of this project is to design and implement a simple interface for the
            user to graphically program basic functions. Simple functions may include:

            \begin{itemize}
                \item loops.
                \begin{itemize}
                    \item this includes \texttt{for} and \texttt{while} loops.
                \end{itemize}
                \item conditional statements, such as \texttt{if} statements.
                \item implementing and interacting with data structures, such as lists.
                \item procedures like methods/functions.
                \item variables!
            \end{itemize}
            
            This is necessary as it provides another programming viewpoint for the user,
            which can aid them understand the process and flow of how said program may
            be running. It is also friendly and less intimidating for newer users,
            relative to a textual/command line script.
            
            I am going to program this is Java, my most experienced language, making use
            of Java's smart GUI design feature, whilst learning and building knowledge on
            said feature for my own experience.

        \subsection{Objectives}
            The main objectives are:

            \subsubsection{To investigate software requirements to produce a requirements
            specification.}
                It is important to clarify what the software requirements are for this project as they
                define whether this project will work or not. Without the mandatory requirements,
                the game will not be properly functional. I investigated what requirements are mandatory
                by doing research on existing softwares such as App Inventor and Blockly. For instance,
                all softwares I found had a \texttt{run} button in order to be able to run the graphical
                entities. Without this, how else is the canvas run? Of course it is not a big deal, and
                there would probably be another solution, but it's a simple feature that also provides
                simple UI for the user, which is self explanatory.

            \subsubsection{To select and justify an appropiate simple design for the
            project.}
                This objective is to research other designs of similar projects and to understand
                why their interface works well from a new user's perspective, but also why it
                doesn't work very well. My knowledge in Human-Computer Interaction will help me
                to focus on the design, and what defines a \textit{"user-friendly"} design.
                The goal here isn't implementing the design, it's creating a design, on pen paper,
                attempting to make it as self-explanatory as possible. But that also begs the question,
                \textit{"what determines a self-explanatory design?"} It's important to realise that
                everyone's judgement of what a simple design looks like is different. It's a subjective
                topic but I must ensure I use the principles learnt from HCI about simple design and
                user-friendly interaction to make a design at the best of my ability.
            
            \subsubsection{Implement a simple interface for users which is easy to
            understand.}
                An important objective, which builds off of \texttt{1.2.2}. I have limited GUI
                experience, where the first and last GUI building I engaged with was in 2nd year,
                Further Programming module, with Dr. Ian Wakeman. I spent a lot of time during that
                assignment at the time focusing on a simple interface for the Futoshiki puzzle.

                This objective will benefit me greatly. Through research and problems, I will
                get through this objective and implement an interface, whether it be outstanding,
                or just about finished, and I will gain a lot of knowledge and experience on
                the way.

            \subsubsection{Functional and working loops, conditionals, data structures and
            variables that can be interacted with.}
                What's the point of having a pretty canvas if you can't do anything with it?
                This is the meat of the project, what's going to make the project be useful.
                The main objective here is this one. My main priority is the ability to get
                this project off its feet.
                Variables for user's to be able to create and store data with, as well as
                interact with within the project. Loops to allow the user to work with logic,
                data structures that can be possibly altered, such as sorting. Without this
                objective being met, it's just a pretty GUI with no functionality.

        \subsection{Problem Area}
            The main challenge of implementing an interface to be able to program on is the required 
            time and skill set. This project may never be fully complete as more work can always be 
            done to improve the functionality of the interface, or making the interface more user-friendly.

            The project can be broken down into key areas that require focusing on:
        
            \begin{itemize}
                \item Graphical Design - modelling, interface, simplicity, GUI.
                \item Functionality - programming.
            \end{itemize}

            I have limited GUI design in Java from my 2nd year module, Further Programming, therefore this 
            process can be said to take up a large amount of time. Careful consideration is needed to 
            not overspend my time on the GUI design process, and rather get the functionality of said 
            interface to work.

            Functionality requires programming to be clean and efficient, so not to go back over the code 
            and forget what was written. Code must be documented and commented along the way to make sure 
            anyone who reads the code, including myself in the future, is able to understand what was 
            written and why it was decided.

            \subsection{Expected Outcomes}
            The expected outcomes of this project are a fully working, functional graphical programming 
            language interface. The user should use the tool independent from the back-end Java textual 
            code, and be able to perform the certain tasks:

            \begin{itemize}
                \item loops - create and work with basic for \& while loops.
                \item data structures - create and interact with data structures such as lists.
                \item variables - create, store data and interact with variables.
                \item procedures - create functions/methods to perform certain tasks inside them!
                \item interface - an interface for users to be able to interact with and perform the
                above outcomes.
            \end{itemize}

            What do we expect it to behave/look like? A blank canvas should appear upon starting, with
            a heading on the left hand side, presenting the user with a selection of choice such as
            \textit{"Loops, Procedures"} and so on, for each category of block. They will be able to click
            on said heading, which will expand and show the different blocks they can choose from. So if
            they chose the \textit{loops} heading (a draft name for now, I know), this will expand and show
            for \& while loops for them to choose from.

            An important point to address, is what will happen when the user runs the program? This is a key
            concept which will be an ongoing investigation throughout the project. But the current idea is
            simple: an output screen showing the terminal. Upon running, a heading on the right hand side,
            or perhaps underneath, will pop out with the terminal showing you the output of your program.


            \subsection{Relevance}
            This project involves modules across my degree, as well as Java; the most extensively
            used language across my university education thus far. This project will use skills learnt
            in Human Computer Interaction; test my ability to understand the user's perspective and
            struggles, involving the evaluation of the software, rather than my own when designing
            the interface for them to use.
        
            This project also incorporates key concepts understood from Software Engineering.
            The ability to criticse my own work, collect requirements, manage time and manage an
            agile approach to the project. Therefore, this project will test my ability to make use
            of several skills in such a way that they will be used outside of my university education.

    \clearpage
    \section{Professional and Ethical Considerations}
        Below you will find the relevant sections of the BCS Code Conduct that apply to this 
        project. Since this project will not require any human participation, no ethical review 
        is necessary.

        \subsection{BCS Code of Conduct}
            \textbf{1.1 - have due regard for public health, privacy, security and wellbeing of others 
            and the environment;} \\\\
            This project does not feature any distressing visuals that may harm the user. \\\\
            \textbf{2.1 - only undertake to do work or provide a service that is within your professional 
            competence;} \\\\
            This project is within my professional skillset to complete. \\\\
            \textbf{2.3 - develop your professional knowledge, skills and competence on a continuing 
            basis, maintaining awareness of technological developments, procedures, and standards 
            that are relevant to your field;} \\\\
            Throughout this project I will maintain my skills, but further learn and research new ideas 
            or more experienced methods to make my skills more proficient within the field. \\\\
            \textbf{2.5 - respect and value alternative viewpoints and seek, accept and offer honest 
            criticisms of work;} \\\\
            I will accept feedback by my supervisor and others and use the criticisms to develop and 
            build upon the project further. Results of feedback will not be edited. \\\\
            \textbf{3.2 - seek to avoid any situation that may give rise to a conflict of interest 
            between you and your relevant authority;} \\\\
            Throughout the project I will be respect to my colleagues and my supervisor.

    \clearpage
    \section{Related Work}
        \subsection{Scratch}
            The key goal that Scratch sticks by is trying to introduce programming to those with no
            programming experience knowledge whatsoever. Scratch has been widely distributed to school
            systems and education organisations~\cite{maloney2010scratch}. Scratch also couldn't be any
            more clearer to use, with a heading of categories for you to choose and select the difference
            blocks that provide different functionality.

            \begin{figure}[h]
                \centering
                \includegraphics{scratch_blocks.png}
                \caption{Scratch's categories of blocks that you can select from.}
            \end{figure}

            The user doesn't require any documentation to understand how to use Scratch, rather they
            are able to learn on the go, hence why it is suitable to new programmers trying to get a
            basic feel of the approach and what programming can do, as well as what you are able to
            do with it!

        \subsection{MIT App Inventor}
            MIT App Inventor is another graphical programming language for building apps for Android devices.
            App Inventor is used across 195 countries, in education organisations and also self-taught
            \cite{xie2016skill}. 

            \begin{figure}[h]
                \centering
                \includegraphics[width=125mm]{scratch_vs_appinventor.png}
                \caption{Graphical style of Scratch vs App Inventor~\cite{park2019comparing}. App Inventor is slightly more sophisticated.}
            \end{figure}

            \clearpage
            Scratch and MIT App Inventor are the two most widely used block-based graphical programming
            languages for students and/or pupils. As of August 2019, there were 44,981,198 registered
            users on Scratch, and 8,200,000 registered users on App Inventor~\cite{park2019comparing}.

            Both Scratch and App Inventor share the common goal of providing an educational programming
            language for new comers. Scratch is mainly used as a foundation to teach younger children
            the concepts of code, whereas App Inventor is used as the \textit{"step up"}, but both are
            used globally to make programming a bit more fun and interactive. App Inventor in particular
            is rewarding as upon running the code, an interactive mobile phone displaying your app is
            shown as the output!

        \subsection{Blockly}
            Blockly is probably by far the most modern out of the three I have proposed, and the 
            most intuitive. It's a free, web-based, open-source project by Google, built upon the 
            idea of Scratch. But what's intuitive about Blockly is the textual programming output 
            on the right-hand side of your graphical code. It can generate code in the following 
            languages~\cite{nbcbayarea}:

            \begin{itemize}
                \item Javascript.
                \item Lua.
                \item Dart.
                \item Python.
                \item PHP.
            \end{itemize}

            It can also be edited to generate code in a different textual programming language!

            \begin{figure}[h]
                \centering
                \includegraphics[width=150mm]{blockly.png}
                \caption{Blockly's modern and simple block programming design, as well 
                as the option to choose the programming language that it will syntactically 
                output as~\cite{blockly}.}
            \end{figure}

            Blockly is aimed towards new programmers to get them onboard and addicted to the visual 
            scene first. By providing the textual version of the code, perhaps this might spark a 
            passion within the user to follow through with programming. By being provided with the 
            textual code of their graphical app, they are learning and understanding what the code 
            will really look like and how they could potentially implement it themselves.

            A key part of Blockly that the developers undertook was user testing. The conditional and loop blocks were in the same category, with the same colour, 
            confusing the users who expected the program to run a certain way, when it ran differently 
            to what they were expecting ~\cite{fraser2015ten}. The developers understood this and 
            learnt from the feedback quickly, moving the conditionals to a different category, as 
            well as changing the colour too. This removed the confusion instantly. These key ways to improve 
            from feedback received is key to building a successful project.
        
        \clearpage
        \subsection{Graphical Programming}
            What all three graphical programming editors do together is follow the convention 
            of lower-case naming of variables, functions and so on that is followed in textual-based
            programming languages, for instance \textit{"if"} and \textit{"while"}. 

            \begin{figure}[h]
                \centering
                \includegraphics{lowercase_convention.png}
                \caption{The lowercase convention, as followed by Blockly as an example~\cite{pasternak2017tips}.}
            \end{figure}

            Graphical programming is not a permanent solution to programming, but rather an 
            introduction~\cite{gregoryvisual}. Users are being taught the convention of the key
            syntax that is used across all languages. I plan to follow this convetion too. A
            picture is worth a thousand words~\cite{petre1995looking}, and reading code isn't learnt
            nearly as fast and reading a picture. The strength of graphical representations is
            that they complement perceptually something also expressed textually in this case.

    \clearpage
    \section{Requirements Analysis}
        In this section, I have taken into careful consideration the aims and objectives for this
        project. Below you will find a compiled list of software requirements, split into two
        categories: \textbf{mandatory} requirements, the fundamental requirements that is needed
        for the project to work, and \textbf{desirable} requirements, optional further requirements
        that can be met to provide further quality of life experiences for the user.

        \subsection{Mandatory Requirements}

            \begin{table}[h]
                \begin{tabular}{|l|l|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{Mandatory Requirements}}                                                                                                                                                                                                             \\ \hline
                    \textbf{Requirement}                                                                                                     & \textbf{Specification}                                                                                                                 \\ \hline
                    \begin{tabular}[c]{@{}l@{}}1. Application will work on any java-run\\ environment.\end{tabular}                          & \begin{tabular}[c]{@{}l@{}}Whether the user is on a Windows, macOS\\ or Linux system, the application will work.\end{tabular}          \\ \hline
                    \begin{tabular}[c]{@{}l@{}}2. The interface shall accept user input\\ via keyboard and mouse.\end{tabular}               & \begin{tabular}[c]{@{}l@{}}User will be able to use keyboard and mouse\\ to create and interact with the canvas.\end{tabular}          \\ \hline
                    3. The program shall run until is it killed.                                                                             & \begin{tabular}[c]{@{}l@{}}The process will not stop running until either\\ it is killed via user or forced shutdown.\end{tabular}     \\ \hline
                    \begin{tabular}[c]{@{}l@{}}4. The program will output any errors,\\ if any.\end{tabular}                                 & \begin{tabular}[c]{@{}l@{}}If there are any run-time errors, the terminal\\ will output those for the user to see.\end{tabular}        \\ \hline
                    \begin{tabular}[c]{@{}l@{}}5. The user shall be able to use functional\\ loops such as for and while loops.\end{tabular} & \begin{tabular}[c]{@{}l@{}}The user will have the ability to interact with\\ loops in the interface.\end{tabular}                      \\ \hline
                    \begin{tabular}[c]{@{}l@{}}6. The user shall be able to create\\ variables.\end{tabular}                                 & \begin{tabular}[c]{@{}l@{}}The user will be able to create and interact\\ with variables.\end{tabular}                                 \\ \hline
                    \begin{tabular}[c]{@{}l@{}}7. The user shall be able to create\\ functions or procedures.\end{tabular}                   & \begin{tabular}[c]{@{}l@{}}Users will have the ability to create functions\\ /methods that perform a variety of tasks.\end{tabular}    \\ \hline
                    \begin{tabular}[c]{@{}l@{}}8. The user will be able to create data\\ structures.\end{tabular}                            & \begin{tabular}[c]{@{}l@{}}Data structures such as lists will be available\\ for the user to implement and interact with.\end{tabular} \\ \hline
                    9. A run button.                                                                                                         & A button to run to be able to run their program.                                                                                       \\ \hline
                \end{tabular}
            \end{table}

        \clearpage
        \subsection{Desirable Requirements}
            \begin{table}[h]
                \begin{tabular}{|l|l|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{Desirable Requirements}}                                                                                                                                                                                                                                                                           \\ \hline
                    \textbf{Requirement}                                                   & \textbf{Specification}                                                                                                                                                                                                                                 \\ \hline
                    1. Colour coded blocks.                                                & \begin{tabular}[c]{@{}l@{}}The designs can be colour coded to visually\\ aid the user what they represent. For instance,\\ orange blocks for variables.\end{tabular}                                                                                   \\ \hline
                    2. Interactive sound design.                                           & \begin{tabular}[c]{@{}l@{}}A potential sound that can be producing by\\ interacting with the program. For instance,\\ dragging and dropping, clicking, etc...\end{tabular}                                                                             \\ \hline
                    \begin{tabular}[c]{@{}l@{}}3. Highlight when mouse\\ over\end{tabular} & \begin{tabular}[c]{@{}l@{}}When the mouse is hovered over an object,\\ said object could be highlighted by a glowing\\ fade, or perhaps an outline of the object.\end{tabular}                                                                         \\ \hline
                    4. Recycling bin.                                                      & \begin{tabular}[c]{@{}l@{}}A recycling bin in the bottom corner to show\\ users where they can drag and drop blocks\\ that are not needed. This could only be visible\\ when an object is being dragged, or it could always\\ be visible.\end{tabular} \\ \hline
                    5. Undo button.                                                        & A button to undo an action.                                                                                                                                                                                                                            \\ \hline
                    6. Redo button.                                                        & A button to redo an action if undone.                                                                                                                                                                                                                  \\ \hline
                \end{tabular}
            \end{table}

        My aim is to attempt to achieve all the mandatory requirements as they are underlying
        foundations of the program. All the requirements work together to build the program. 
        Without any of these requirements, this will fail to work effectively. The desirable 
        requirements that I would like to be able to implement include the undo + redo button, 
        as well as the recycling bin! Thinking about the user's goals here, these would be 
        incredibly impactful towards benefiting their quality of life experience. Having the 
        ability to undo/redo any mistakes you make, as well as simply drag and drop to the bin 
        to delete unnecessary content, only makes the lives of the user easier.

    \clearpage
    \section{Project Plan}
        Below in figure 7 is a gantt chart outlining my process to progress through this task.
            
        \begin{figure}[h]
            \centering
            \includegraphics[width=150mm]{gantt_chart.png}
            \caption{My gantt chart displaying the process I intend to follow throughout
            the project.}
        \end{figure}

        \subsection{Completed Work}
            As of the time of this report being handed in, all the work I have completed thus
            far are the following:

            \begin{itemize}
                \item Project proposal - outlining my objecives, aims and motivations for the
                project.
                \item Background research - related work to the project I am working on.
                \item Requirements gathering - software requirements that must be met for
                the project to work, as well as some desirable objectives for quality of
                life improvements!
                \item Interim report.
            \end{itemize}

        \subsection{What's to come}
            After completing this, I plan to have a meeting with my supervisor soon to discuss
            design ideas for the project, and what the GUI might potentially look like.

            Of course, throughout the project my draft report will be the main task. Although
            my gantt chart shows a period in March-April where I will be hard focusing on it,
            throughout the project, I do plan to add bits here and there to it, to get started.

        \subsection{Other Tools}
            I have utilised a private Github repository for version control.

            \begin{figure}[h]
                \centering
                \includegraphics[width=110mm]{github.png}
                \caption{My Github private repository for the project.}
            \end{figure}
    
    \clearpage
    \section{Some section}
    What I do at the beginning of this project is crucial to what will come up ahead since this
    will be the foundation of the entire project. How I will present the work to the user. Before
    I can begin getting into the deep fundamentals of this project, I must first, but most
    importantly of all, design the basic canvas GUI (graphical user interface) for the user to
    be able to see! This initial design of this interface will be a blank canvas, hopefully
    with a left-hand side panel where the blocks will be.

    To begin, I will start with the blank canvas, then leading onto dividing the canvas into two
    so there is a left side panel, and in this panel, a print block that the user will be able
    to drag and drop. The functionality will not matter currently at this stage, but it's
    essential I research how I will implement the blocks, as this is the commitment I will need
    to take for the rest of the project. I will start with making the blocks out of buttons.
    I should note that the reason the start of this project is the most important and requires
    careful thought and consideration is simply that this is not a small project. I must
    ensure that whatever I do now will work for the remainder of the project, and that it will
    be compatible with any functionality I will implement later. If I don't consider this
    carefully, there may be a chance that I might hit a dead end and I will have to come back
    to this stage, at a time where I shouldn't be. \\

    Jack from the following thread on stackoverflow provided a interesting answer to center
    the JFrame for the user.
    https://stackoverflow.com/questions/2442599/how-to-set-jframe-to-appear-centered-regardless-of-monitor-resolution \\

    The design on the program will look like this. https://stackoverflow.com/questions/13057836/using-two-jpanels-in-one-jframe

    \begin{figure}[h]
        \centering
        \includegraphics[width=150mm]{design.png}
        \caption{Credit to user Kynian for the design, one which will be similar to mine.}
    \end{figure}

    Add space to buttons to prevent them from hugging the wall https://stackoverflow.com/questions/2212647/java-how-do-i-prevent-borderlayout-east-from-hugging-the-side-of-the-screen \\

    stop resizing program to small !!!!!!!!!!!!!!! \\
    i need another panel for console output, spawn a new instance to output console \\

    \clearpage
    I ran into a problem whereby in Java Swing, when I added padding to the border edges that
    are touching the edges of the JFrame, the background colour filled outside the border. \\

    https://docs.oracle.com/javase/tutorial/uiswing/painting/closer.html \\

    Firstly, the background of the panel is painted. Then the border is painted afterwards
    - weather a compound border function is used where the function allows you to
    specify the border objects for the outside and inside edges. Secondly, then the border
    is painted on top of the panel. In the case of my panels, only the line is painted on
    top of the background. I will be used a compound border to adjust the margins for the
    borders around the panels. I will run into this issue where the white background colour
    I choose will overflow. \\

    \begin{figure}[h]
        \centering
        \includegraphics[width=80mm]{colour_overfill.png}
        \includegraphics[width=100mm]{overfill_solution.png}
        \includegraphics[width=80mm]{no_overfill.png}
        \caption{The white background overflowing above the border in the top image; my solution
        to the current problem, and the gray background now just appearing as a white background.
        No one liked a gray background anyway.}
    \end{figure}

    The procedure forward is to design the application only using a print statement. Upon
    succeeding with said functionality, the follow up for the remainder of the implementations
    would function more or less the same, and it should be an easy job of copy and paste.
    I created a button named "print statement" that would be the button used to initialise
    - you got it - a print statement! Woohoooo. The next importatnt step was reproducing this
    in the main canvas panel. I implemented functionality that listens to the mouse clicks,
    thus once the button is pressed, it clones it on the canvas to be used. Initially I was
    going to implement the \texttt{Cloneable} library but I came across an article that suggested
    otherwise. \texttt{Cloneable} is broken and shouldn't be used as the architecture was
    essentially mistaken, and it's only there for backward compatibility reasons. /cite/ So
    I followed up by implementing the copy constructor suggestion that takes a component
    as an argument and returns the said component as a new entity.
    https://www.artima.com/intv/bloch.html \\

    \begin{figure}[h]
        \centering
        \includegraphics{copy_constructor.png}
        \caption{Some caption of the constructor.}
    \end{figure}


    interpreter comparative programming \\

    click button to spawn the block on the canvas

    and drag.

    and rubbish bin


    \clearpage
    \section{Appendix}
        \subsection{Interim Log}
            \textbf{Friday 23\textsuperscript{rd} October}
                \begin{itemize}
                    \item Discussing what my key interests are.
                    \item Deciding which projects are suitable for me.
                    \item Showing me some of my supervisor's projects. 
                    \item Going through the introduction of the project proposal. \\
                \end{itemize}
            \textbf{Monday 9\textsuperscript{th} November} 
                \begin{itemize}
                    \item Focusing on time management between project and university
                    studies.
                    \item Strong introduction, that explains what I'm doing!!
                    \item Project proposal:
                    \begin{itemize}
                        \item deeper detailed objectives.
                        \item be more specific if I can.
                    \end{itemize}
                    \item grouping objectives into one group, not several.
                \end{itemize}

    \clearpage
        \subsection{Project Log}
            \textbf{}

        \clearpage
        \subsection{Project Proposal}
            \textbf{Motivations} \\\\    
            The motivation behind this project it that it will push my Java programming
            skills to limit, and experience designing software for other people rather
            than just for my own benefit. This will help me put my focus on the user's
            goals rather than my own. Additionally, I can put this project on my portfolio
            to show future employers!

            This project will further put content learnt from modules in my degree to                practice. Time management techniques from Software Engineering will help me
            manage when and what I should be focusing on. Furthermore, concepts learnt
            from Human Computer Interaction will aid me in focussing on user design for
            the user's goals; implementing a user interface that everyone will be able to
            use effectively.
        
            Finally, the ability to use Java this extensively will most definitely improve
            my proficiency of the skill! \\\\
            \textbf{Aims} \\\\
            The aim of this project is to design and implement a user friendly interface for
            the user to graphically program basic functions. Simple functions may include:
            \begin{itemize}
                \item loops.
                \begin{itemize}
                    \item this includes \texttt{for} and \texttt{while} loops.
                \end{itemize}
                \item conditional statements, such as \texttt{if} statements.
                \item implementing and interacting with data structures, such as lists.
                \item procedures like methods/functions.
                \item variables!
            \end{itemize}
            
            This is necessary as it provides another programming viewpoint for the user,
            which can aid them understand the process and flow of how said program may be running.
            It is also friendly and less intimidating for newer users, relative to a textual/command
            line script.
                
            I am going to program this is Java, my most experienced language, making use of Java's
            smart GUI design feature, whilst learning and building knowledge on said feature for my
            own experience. \\\\
            \textbf{Objectives} \\\\
            The main objectives are:
            \begin{enumerate}
                \item To investigate system requirements and produce a requirements specification.
                \item To select and justify an appropiate research design for the project.
                \item Implement a simple user-friendly interface which is easy to use.
                \item Functional and working loops, conditionals and data stuctures that can be interacted
                with. \\
            \end{enumerate}        
            \textbf{Exta Objectives}
            \begin{enumerate}
                \item Colour coordinate the different functions.
                \begin{itemize}
                    \item for instance, the loops and conditionals can be coloured differently to show more
                    clearly what they represent.
                \end{itemize}
                \item Implement an undo button.
                \item Implement a redo button.
                \item Testing by a regular user, of the software.
            \end{enumerate}
            \textbf{Relevance} \\\\
            This project involves modules across my degree, as well as Java; the most extensively
            used language across my university education thus far. This project will use skills learnt
            in Human Computer Interaction; test my ability to understand the user's perspective and
            struggles, involving the evaluation of the software, rather than my own when designing
            the interface for them to use.
        
            This project also incorporates key concepts understood from Software Engineering.
            The ability to criticse my own work, collect requirements, manage time and manage an
            agile approach to the project. Therefore, this project will test my ability to make use
            of several skills in such a way that they will be used outside of my university education. \\\\
            \textbf{Resources Required} \\\\
            None. \\\\
            \clearpage
            \textbf{Personal Timetable}
                \begin{figure}[h]
                    \centering
                    \includegraphics[width=175mm]{timetable.png}
                \end{figure}    

    \clearpage
    \printbibliography
\end{document}